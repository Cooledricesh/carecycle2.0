{
  "rules": [
    {
      "type": "prd",
      "content": "# 📘 CareCycle PRD (Product Requirements Document)\n\n## 1. 제품 개요\n\n* **제품명:** CareCycle\n* **문서 목적:** MVP 단계에서 개발할 CareCycle 앱의 필수 기능 및 요구사항을 명확하게 정의하여, 병원 직원의 업무 효율성을 높이고 검사·주사 관리 업무를 획기적으로 간소화하는 것이 목적이다.\n* **목표 사용자:** 정신건강의학과 의료진 및 행정 직원\n* **핵심 목표:** 직원들의 반복적이고 시간 소모가 많은 수작업(일정 관리 및 시행 확인)을 자동화하여 업무 부하를 최소화\n\n---\n\n## 2. 현황 및 문제 정의\n\n### 현황\n\n* 총 관리 환자 수: 최대 220명 (검사: 220명, 주사: 150명)\n* 검사 종류: 3개월마다 심리검사, 6개월마다 뇌파검사\n* 주사 종류: 4주, 12주, 24주 간격의 장기지속형 주사제\n\n### 핵심 문제점\n\n* 일정 관리 및 계산의 수작업 부담\n* 시행 여부 확인에 따른 시간 소비\n* 반복 업무로 인한 직원의 업무 피로도 상승\n* 기존 EMR 시스템과 연동 불가\n\n---\n\n## 3. MVP 필수 기능\n\n### 1. 환자 일정 자동 관리\n\n* 환자 기본 정보 입력 (이름, 환자 번호)\n* 주사 및 검사 주기 설정\n* 최초 시행 날짜 기준으로 자동 일정 계산\n\n### 2. 자동화된 체크리스트 및 시행 여부 입력\n\n* 매일 예정된 검사·주사 환자 목록 자동 생성 및 제공\n* 간편 체크(클릭 방식)로 시행 여부 및 실제 시행 날짜 입력\n* 시행 여부는 단순한 체크박스 및 간략 메모 입력 가능\n\n### 3. 간편 알림 시스템\n\n* 예정된 날짜에 자동 알림 (모바일 Push 알림 및 웹 알림)\n* 실제 시행 날짜를 기준으로 다음 검사·주사 일정 자동 재계산\n\n### 4. 현황 관리 대시보드\n\n* 간략한 대시보드를 통해 당일 및 전체 진행 상황 제공\n* 직관적인 상태 표시 (컬러 코드 활용)\n\n### 5. 항목 추가 기능\n\n* 사용자가 쉽게 새로운 검사나 주사 항목을 추가하여 관리 가능\n* 간단한 설정(이름, 주기)만으로 즉시 반영 및 관리 시작\n\n---\n\n## 4. UX/UI 요구사항\n\n* 모든 입력 및 조회 과정은 최대 2\\~3회 클릭 이내로 처리\n* 간단하고 직관적인 디자인 및 레이아웃\n* 명확한 상태 구분을 위한 컬러 코딩 활용\n\n---\n\n## 5. 기술적 요구사항\n\n| 영역          | 사용 기술                      |\n| ----------- | -------------------------- |\n| 프론트엔드 (웹)   | Next.js, Vercel, shadcn/ui |\n| 프론트엔드 (모바일) | FlutterFlow                |\n| 백엔드 및 API   | Supabase                   |\n| 데이터베이스      | Supabase (PostgreSQL 기반)   |\n| 알림 서비스      | Supabase, Resend           |\n\n### 단순화된 아키텍처\n\n```\n┌─────────────┐     ┌─────────────┐\n│   Next.js   │     │ FlutterFlow │\n│   (Vercel)  │     │  (Mobile)   │\n└──────┬──────┘     └──────┬──────┘\n       │                   │\n       └─────────┬─────────┘\n                 │\n         ┌───────▼────────┐\n         │   Supabase     │\n         │ - Database     │\n         │ - Auth         │\n         │ - Realtime     │\n         └────────────────┘\n```\n\n---\n\n## 6. 제외 기능 (후속 개발 대상)\n\n* 고급 보고서 생성 기능 (PDF, Excel Export)\n* 복잡한 일정 최적화 알고리즘\n* 다중 사용자 및 세부 권한 설정\n* EMR 연동\n\n---\n\n## 7. 기대 효과\n\n* 업무 관리에 소요되는 시간 최소 50% 이상 절약\n* 업무 정확성 향상 및 누락 업무 감소\n* 직원들의 반복 업무 스트레스 감소\n\n---\n\n## 8. 향후 개선 계획\n\n* 직원 현장 피드백 적극 수용 및 반영\n* 제외된 고급 기능을 단계적으로 추가하여 지속 가능한 발전 도모\n* SaaS 형태로의 확장 및 병원별 데이터 분리(RLS 기능 고려)\n",
      "writedAt": "2025-08-06T15:29:07.982Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n\n- **프로젝트 개요**  \n  CareCycle MVP는 정신건강의학과 의료진 및 행정 직원의 검사·주사 일정 관리 업무를 자동화하여 반복 작업 부담을 최소화하는 웹·모바일 애플리케이션입니다. Next.js(웹), FlutterFlow(모바일), Supabase(PostgreSQL 기반 백엔드)를 중심으로 단순하고 유지보수 용이한 구조로 설계합니다.\n\n- **Core Technology Stack**  \n  - 프론트엔드(Web): Next.js + shadcn/ui  \n  - 프론트엔드(Mobile): FlutterFlow  \n  - 백엔드/API: Supabase (Auth, Realtime, Edge Functions)  \n  - 데이터베이스: Supabase(PostgreSQL)  \n  - 배포: Vercel  \n  - 알림: Supabase Edge Functions + Resend  \n\n- **Key Technical Objectives**  \n  - 응답 시간: 평균 200ms 이하(페이지 전환/알림 트리거)  \n  - 가용성: 99.9% 이상  \n  - 확장성: 초기 500명 사용자, 향후 수천 명 확장 대비  \n  - 보안: RLS 적용, HTTPS 전송, 인증·인가 강화\n\n- **Critical Technical Assumptions**  \n  - EMR 연동은 MVP 제외  \n  - 비개발자도 사용 가능한 UI/UX  \n  - Supabase 및 Vercel 기반 배포·호스팅  \n  - 외부 리소스 추가 연동 최소화\n\n## 2. Tech Stack\n\n| Category             | Technology / Library                    | Reasoning (선택 이유)                                            |\n| -------------------- | --------------------------------------- | --------------------------------------------------------------- |\n| Web Frontend         | Next.js                                  | SSR/SSG 지원, Vercel 최적화, 빠른 개발 생산성                  |\n| UI Library           | shadcn/ui                                 | Tailwind 기반 컴포넌트 제공, 직관적 디자인 구현                |\n| Mobile Frontend      | FlutterFlow                              | 노코드/로우코드 모바일 앱 신속 개발, 비개발자용 UX 쉬움       |\n| Backend / API        | Supabase                                 | 서버리스 PostgreSQL, Auth·Realtime·Edge Functions 통합        |\n| Database             | Supabase (PostgreSQL)                    | 완전 관리형 DB, RLS로 데이터 분리·보안 강화                   |\n| Authentication       | Supabase Auth                            | 이메일/패스워드 기반 간편 인증, JWT 토큰 관리                 |\n| Real-time            | Supabase Realtime                        | WebSocket 기반 실시간 업데이트, 간단 구독 모델                |\n| Notification Service | Supabase Edge Functions + Resend         | 서버리스 함수로 푸시·이메일 알림, 외부 종속성 최소화           |\n| Deployment           | Vercel                                   | Next.js 배포 최적화, CI/CD 자동화, 무중단 배포 지원            |\n\n## 3. System Architecture Design\n\n### Top-Level building blocks\n- Web Frontend (Next.js on Vercel)  \n  • 페이지 라우팅, 서버 사이드 렌더링, API 호출  \n- Mobile Frontend (FlutterFlow)  \n  • 모바일 네이티브 UI, Supabase SDK 연동  \n- Backend & API (Supabase)  \n  • Auth, Database, Realtime, Edge Functions  \n- Database & Realtime (PostgreSQL + Realtime)  \n  • 일정 데이터 저장, 실시간 업데이트 알림  \n- Notification Service (Resend via Edge Functions)  \n  • 이메일/푸시 알림 발송 로직  \n\n### Top-Level Component Interaction Diagram\n```mermaid\ngraph TD\n    A[Next.js 웹] --> B[Supabase API]\n    C[FlutterFlow 앱] --> B[Supabase API]\n    B --> D[PostgreSQL DB]\n    B --> E[Supabase Realtime]\n    B --> F[Edge Functions]\n    F --> G[Resend 알림]\n```\n\n- Next.js 및 FlutterFlow가 Supabase API를 통해 인증, 일정 조회/수정 요청을 수행  \n- Supabase는 PostgreSQL에 데이터를 저장·조회하고 Realtime으로 업데이트 전파  \n- Edge Functions가 알림 트리거를 처리하여 Resend로 이메일/푸시 발송  \n\n### Code Organization & Convention\n\n**Domain-Driven Organization Strategy**  \n- 도메인 분리: 일정 관리, 사용자, 알림 등 비즈니스 도메인별 모듈화  \n- 계층 구조: Presentation(웹/모바일 UI), Application(비즈니스 로직), Infrastructure(Supabase 연동)  \n- 기능 기반 모듈: 반복 업무, 체크리스트, 대시보드 등 기능 단위로 파일 그룹화  \n- 공유 컴포넌트: 공통 유틸리티, 타입, 인터페이스를 shared 모듈에 배치  \n\n**Universal File & Folder Structure**\n```\n/\n├── apps\n│   ├── web\n│   │   ├── pages                  # Next.js 페이지 라우트\n│   │   ├── modules                # 도메인별 기능 모듈\n│   │   ├── components             # UI 컴포넌트\n│   │   ├── lib                    # Supabase 클라이언트 등 라이브러리\n│   │   └── styles                 # 전역 스타일\n│   └── mobile                     # FlutterFlow 프로젝트 디렉토리\n├── services\n│   ├── supabaseClient.ts          # Supabase 초기화 및 설정\n│   └── notifications.ts           # Edge Functions 알림 로직\n├── shared\n│   ├── types                      # 공통 타입 정의\n│   └── utils                      # 범용 유틸리티 함수\n└── README.md\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: Next.js API Routes, FlutterFlow HTTP 요청 → Supabase REST/JS SDK  \n- **Database Interaction**: Supabase JS SDK 이용한 CRUD, 쿼리 빌더, 인덱스 활용  \n- **External Service Integration**: Supabase Edge Functions에서 Resend API 호출  \n- **Real-time Communication**: Supabase Realtime 구독으로 데이터 변경 알림 반영  \n- **Data Synchronization**: 클라이언트 캐시 + Realtime 업데이트로 일관성 유지  \n\n## 4. Performance & Optimization Strategy\n- 서버사이드 렌더링(SSR) 및 정적 생성(SSG) 활용으로 초기 로딩 속도 향상  \n- Supabase 쿼리 튜닝 및 인덱스 적용으로 DB 응답 시간 최소화  \n- 코드 스플리팅 및 레이지 로딩으로 번들 크기 축소  \n- 클라이언트 캐싱 전략(브라우저 캐시, SWR) 적용  \n\n## 5. Implementation Roadmap & Milestones\n\n### Phase 1: Foundation (MVP Implementation)\n- Core Infrastructure: Supabase 프로젝트, Vercel 연동, FlutterFlow 초기 설정  \n- Essential Features: 환자 일정 자동 계산, 일별 체크리스트, 알림 트리거, 대시보드  \n- Basic Security: Supabase Auth, RLS 정책, HTTPS 강제화  \n- Development Setup: Git 레포 구성, Vercel Preview, Supabase CI/CD  \n- Timeline: 4주\n\n### Phase 2: Feature Enhancement\n- Advanced Features: 사용자 정의 항목 추가, 메모 기능 강화  \n- Performance Optimization: 쿼리 인덱스 추가, CDN 적용  \n- Enhanced Security: 세션 타임아웃, 역할 기반 접근 제어 기초  \n- Monitoring Implementation: Sentry, Supabase Analytics 대시보드  \n- Timeline: 3주\n\n### Phase 3: Scaling & Optimization\n- Scalability Implementation: Read Replica, 캐시 레이어 도입  \n- Advanced Integrations: SMS/푸시 알림 확장, EMR 연동 준비  \n- Enterprise Features: 다중 사용자, 세부 권한 설정  \n- Compliance & Auditing: 감사 로그, RLS 강화  \n- Timeline: 4주\n\n## 6. Risk Assessment & Mitigation Strategies\n\n### Technical Risk Analysis\n- Technology Risks  \n  • FlutterFlow 기능 한계로 복잡 UI 구현 어려움 → 사전 프로토타이핑  \n- Performance Risks  \n  • Supabase 단일 DB 병목 → 인덱스, 캐시, Read Replica 준비  \n- Security Risks  \n  • 인증/인가 누락 가능성 → RLS 정책, 정기 보안 점검  \n- Integration Risks  \n  • Resend 지연·실패 → 재시도 로직, 백오프 전략\n\n### Project Delivery Risks\n- Timeline Risks  \n  • 요구사항 변경 → 명확한 마일스톤·스코프 관리  \n- Resource Risks  \n  • FlutterFlow·Supabase 경험 부족 → 내부 워크숍, 문서화  \n- Quality Risks  \n  • 테스트 부족으로 버그 잔존 → 자동화 테스트, 코드 리뷰  \n- Deployment Risks  \n  • Vercel 배포 실패 → 스테이징 환경, 롤백 절차 마련  \n- Contingency Plans  \n  • 알림 대체 서비스(SMS 등) 준비, 노코드 플랫폼 대체 방안 확보  ",
      "writedAt": "2025-08-06T15:29:07.982Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-08-06T15:29:07.982Z"
    },
    {
      "type": "tdd",
      "content": "\n# TDD Process Guidelines - Cursor Rules\n\n## ⚠️ MANDATORY: Follow these rules for EVERY implementation and modification\n\n**This document defines the REQUIRED process for all code changes. No exceptions without explicit team approval.**\n\n## Core Cycle: Red → Green → Refactor\n\n### 1. RED Phase\n- Write a failing test FIRST\n- Test the simplest scenario\n- Verify test fails for the right reason\n- One test at a time\n\n### 2. GREEN Phase  \n- Write MINIMAL code to pass\n- \"Fake it till you make it\" is OK\n\n- YAGNI principle\n\n### 3. REFACTOR Phase\n- Remove duplication\n- Improve naming\n- Simplify structure\n- Keep tests passing\n\n## Test Quality: FIRST Principles\n- **Fast**: Milliseconds, not seconds\n- **Independent**: No shared state\n- **Repeatable**: Same result every time\n- **Self-validating**: Pass/fail, no manual checks\n- **Timely**: Written just before code\n\n## Test Structure: AAA Pattern\n```\n// Arrange\nSet up test data and dependencies\n\n// Act\nExecute the function/method\n\n// Assert\nVerify expected outcome\n```\n\n## Implementation Flow\n1. **List scenarios** before coding\n2. **Pick one scenario** → Write test\n3. **Run test** → See it fail (Red)\n4. **Implement** → Make it pass (Green)\n5. **Refactor** → Clean up (Still Green)\n6. **Commit** → Small, frequent commits\n7. **Repeat** → Next scenario\n\n## Test Pyramid Strategy\n- **Unit Tests** (70%): Fast, isolated, numerous\n- **Integration Tests** (20%): Module boundaries\n- **Acceptance Tests** (10%): User scenarios\n\n## Outside-In vs Inside-Out\n- **Outside-In**: Start with user-facing test → Mock internals → Implement details\n- **Inside-Out**: Start with core logic → Build outward → Integrate components\n\n## Common Anti-patterns to Avoid\n- Testing implementation details\n- Fragile tests tied to internals  \n- Missing assertions\n- Slow, environment-dependent tests\n- Ignored failing tests\n\n## When Tests Fail\n1. **Identify**: Regression, flaky test, or spec change?\n2. **Isolate**: Narrow down the cause\n3. **Fix**: Code bug or test bug\n4. **Learn**: Add missing test cases\n\n## Team Practices\n- CI/CD integration mandatory\n- No merge without tests\n- Test code = Production code quality\n- Pair programming for complex tests\n- Regular test refactoring\n\n## Pragmatic Exceptions\n- UI/Graphics: Manual + snapshot tests\n- Performance: Benchmark suites\n- Exploratory: Spike then test\n- Legacy: Test on change\n\n## Remember\n- Tests are living documentation\n- Test behavior, not implementation\n- Small steps, fast feedback\n- When in doubt, write a test\n",
      "writedAt": "2025-08-06T15:29:07.982Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-08-06T15:29:07.982Z"
    },
    {
      "type": "git-commit-message",
      "content": "\n# Git Commit Message Rules\n\n## Format Structure\n```\n<type>(<scope>): <description>\n\n[optional body]\n\n[optional footer]\n```\n\n## Types (Required)\n- `feat`\n- `fix`\n- `docs`\n- `style`\n- `refactor`\n- `perf`\n- `test`\n- `chore`\n- `ci`\n- `build`\n- `revert`\n\n## Scope (Optional)\n- Component, file, or feature area affected\n- Use kebab-case: `user-auth`, `payment-api`\n- Omit if change affects multiple areas\n\n## Description Rules\n- Use imperative mood\n- No capitalization of first letter\n- No period at end\n- Max 50 characters\n- Be specific and actionable\n\n## Body Guidelines\n- Wrap at 72 characters\n- Explain what and why, not how\n- Separate from description with blank line\n- Use bullet points for multiple changes\n\n## Footer Format\n- `BREAKING CHANGE:` for breaking changes\n- `Closes #123` for issue references\n- `Co-authored-by: Vooster AI (@vooster-ai)`\n\n## Examples\n```\nfeat(auth): add OAuth2 Google login\n\nfix: resolve memory leak in user session cleanup\n\ndocs(api): update authentication endpoints\n\nrefactor(utils): extract validation helpers to separate module\n\nBREAKING CHANGE: remove deprecated getUserData() method\n```\n\n## Workflow Integration\n**ALWAYS write a commit message after completing any development task, feature, or bug fix.**\n\n## Validation Checklist\n- [ ] Type is from approved list\n- [ ] Description under 50 chars\n- [ ] Imperative mood used\n- [ ] No trailing period\n- [ ] Meaningful and clear context\n    ",
      "writedAt": "2025-08-06T15:29:07.982Z"
    }
  ]
}